# 4.1.0.4 长列表性能优化

>一个针对长列表的重要优化是，只渲染页面中用户能看到的部分。  
例如一个列表超过5000条，但是当中呈现给用户看到中的一屏显示就只有10条。  
毕竟屏幕有限，你不可能一屏显示完所有列表条目，你需要不断翻页才能看完所有的列表条目。  

>android中的ListView,oc中的TableView中都有复用控件的优化，并且在不断滚动的过程中去除不在屏幕中的元素，不再渲染，从而实现高性能的列表渲染。

>当列表不断往下拉时，web中的dom元素就越多，即使这些dom元素已经离开了这个屏幕，不被用户所看到了，这些dom元素依然存在在那里。  
导致浏览器在渲染时需要不断去考虑这些dom元素的存在，造成web浏览器的长列表渲染非常低效。

>因此，实现的做法就是捕捉scroll事件，当dom离开屏幕，用户不再看到时，就将其移出dom tree。


## jQuery demo

```
<!doctype html5>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
    <title>长列表优化测试</title>
    <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
    <style>
    * {
        padding: 0px;
        margin: 0px;
    }

    li {
        height: 50px;
        line-height: 50px;
        font-size: 20px;
        color: red;
        background: blue;
        border-bottom: solid 1px yellow;
    }
    </style>
</head>

<body>
    <div>长列表测试</div>
    <ul>
    </ul>
    <script>
    var ul = $('ul');
    var newCounter = 1;
    var prefix = $('<li></li>');
    var liCache = []; 
    
    // 第一步 先添加一个占位置高度的 li，和第一条数据
    prefix.css('border', '0px');
    prefix.css('height', '0px');
    ul.append(prefix);
    ul.append('<li>1</li>');
    

    function checkIsBottom(target) {
    	// 判断最后一个元素的位置是不是在视口底部
        var winHeight = window.innerHeight;
        var scrollY = window.scrollY;
        var targetBottom = target.offset().top + target.height();
        return targetBottom > scrollY + winHeight;
    }

    function checkIsTop(target) {
    	// 判断列表第一个元素的位置是不是在视口顶部
        var scrollY = window.scrollY;
        var targetBottom = target.offset().top + target.height();
        return targetBottom > scrollY;
    }

    function newLi() {
        var li;
        if (liCache.length == 0) {
            li = $('<li></li>');
            console.log('new Li,counter:' + newCounter);
            newCounter++;
        } else {
            li = liCache.pop();
        }
        return li;
    }

    function delLi(li) {
        li.remove();
        liCache.push(li);
    }

    function delTopData(li) {
        while (true) {
            //console.log(li.text());
            var nextLi = li.next();
            var height = li.height();
            var prefixHeight = prefix.height();
            delLi(li);
            prefix.height(prefixHeight + height);
            if (checkIsTop(nextLi)) {
                break;
            }
            li = nextLi;
        }
    }

    function addBottomData() {
        var lastLi = $('li:last');
        var counter = parseInt(lastLi.text());
        while (true) {
            var li = newLi();
            li.text(++counter);
            ul.append(li);
            if (checkIsBottom(li)) {
                break;
            }
        }
    }

    function addTopData() {
        var prefixLi = $('li:first');
        var firstLi = $('li:first').next();
        while (true) {
            var newFirstLi = newLi();
            var prefixHeight = prefix.height();
            newFirstLi.text(parseInt(firstLi.text()) - 1);
            firstLi.before(newFirstLi);
            prefix.height(prefixHeight - newFirstLi.height());
            if (prefixLi.height() == 0 || checkIsTop(prefixLi) == false) {
                break;
            }
            firstLi = newFirstLi;
        }
    }

    function delBottomData() {
        var prefixLi = $('li:first');
        var li = $('li:last');
        var prevLi = li.prev();
        while (true) {
            delLi(li);
            li = prevLi;
            prevLi = li.prev();
            if (prevLi.prev()[0] == prefixLi[0] || checkIsBottom(prevLi) == false) {
                break;
            }
        }
    }
    // 第二步，添加一条数据后，依次添加数据，知道最后一条数据触底了
    addBottomData();
    
    // 第三步 监听滚动（向下滚，向上滚），
    $(window).scroll(function() {
        //顶部移除节点
        var firstLi = $('li:first').next();
        // 滚动条向下滑动，页面向上滚动，先把列表上面的数据删掉，缓存下来，
        if (checkIsTop(firstLi) == false) {
            delTopData(firstLi);
        }

        //尾部移除节点
        var suffixLi = $('li:last').prev();
        // 滚动条像上滑动，从列表最后一条前删除数据
        if (checkIsBottom(suffixLi)) {
            delBottomData();
        }

        //尾部添加节点
        var lastLi = $('li:last');
        // 滚动到底部，添加底部数据
        if (checkIsBottom(lastLi) == false) {
            addBottomData();
        }

        //顶部添加节点
        var prerfixLi = $('li:first');

        if (prerfixLi.height() != 0 && checkIsTop(prerfixLi) == true) {
            addTopData();
        }

    });
    </script>
</body>

</html>
```


- 这个demo也存在一些没有实现的地方:
  - 往上拉了以后，底部的列表条目没有留下来，全部都删了，导致下一次往下拉时又要重复拉数据。
  - 列表条目的高度都是固定的
  - 列表条目的数据没有存下来，重建数据时是用附近条目的数据来补充过来的


## 参考
- []()
